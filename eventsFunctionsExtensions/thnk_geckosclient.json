{
  "author": "",
  "category": "Network",
  "extensionNamespace": "",
  "fullName": "THNK Framework - Geckos client adapter",
  "gdevelopVersion": "",
  "helpPath": "https://thnk.cloud/",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjwhLS0gQ3JlYXRlZCB3aXRoIElua3NjYXBlIChodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy8pIC0tPgoKPHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczpzb2RpcG9kaT0iaHR0cDovL3NvZGlwb2RpLnNvdXJjZWZvcmdlLm5ldC9EVEQvc29kaXBvZGktMC5kdGQiCiAgIHhtbG5zOmlua3NjYXBlPSJodHRwOi8vd3d3Lmlua3NjYXBlLm9yZy9uYW1lc3BhY2VzL2lua3NjYXBlIgogICB3aWR0aD0iMzMuNTEyMjcybW0iCiAgIGhlaWdodD0iMjkuNzI1Mzk3bW0iCiAgIHZpZXdCb3g9IjAgMCAzMy41MTIyNzIgMjkuNzI1Mzk3IgogICB2ZXJzaW9uPSIxLjEiCiAgIGlkPSJzdmcxNDQ5NSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi41ICgyMDYwZWMxZjlmLCAyMDIwLTA0LTA4KSIKICAgc29kaXBvZGk6ZG9jbmFtZT0iR2Vja29zLnN2ZyI+CiAgPGRlZnMKICAgICBpZD0iZGVmczE0NDg5IiAvPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBpZD0iYmFzZSIKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMS4wIgogICAgIGlua3NjYXBlOnBhZ2VvcGFjaXR5PSIwLjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp6b29tPSIwLjM1IgogICAgIGlua3NjYXBlOmN4PSItNDY2LjY2OTgiCiAgICAgaW5rc2NhcGU6Y3k9Ii04Ni42ODMyMjEiCiAgICAgaW5rc2NhcGU6ZG9jdW1lbnQtdW5pdHM9Im1tIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9ImxheWVyMSIKICAgICBzaG93Z3JpZD0iZmFsc2UiCiAgICAgaW5rc2NhcGU6d2luZG93LXdpZHRoPSIxOTIwIgogICAgIGlua3NjYXBlOndpbmRvdy1oZWlnaHQ9IjEwNTMiCiAgICAgaW5rc2NhcGU6d2luZG93LXg9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LXk9IjAiCiAgICAgaW5rc2NhcGU6d2luZG93LW1heGltaXplZD0iMSIgLz4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGExNDQ5MiI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+PC9kYzp0aXRsZT4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGcKICAgICBpbmtzY2FwZTpsYWJlbD0iTGF5ZXIgMSIKICAgICBpbmtzY2FwZTpncm91cG1vZGU9ImxheWVyIgogICAgIGlkPSJsYXllcjEiCiAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTU4LjA4MzE3LC05Ni4xNzMwMDEpIj4KICAgIDxwYXRoCiAgICAgICBzb2RpcG9kaTpvcGVuPSJ0cnVlIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBkPSJtIC0yMS43MTQzNjQsMTI5LjYxNTUzIGEgMjQuMzQzMTY2LDguNTgwMzE5NCAwIDAgMSAxNC4xOTQ2OTEzLDYuMDI5MTggMjQuMzQzMTY2LDguNTgwMzE5NCAwIDAgMSAtNS42MTkwMjMzLDcuNTgwMjkiCiAgICAgICBzb2RpcG9kaTplbmQ9IjAuNzI5NjgyMDkiCiAgICAgICBzb2RpcG9kaTpzdGFydD0iNS4xMTYzOTM5IgogICAgICAgc29kaXBvZGk6cnk9IjguNTgwMzE5NCIKICAgICAgIHNvZGlwb2RpOnJ4PSIyNC4zNDMxNjYiCiAgICAgICBzb2RpcG9kaTpjeT0iMTM3LjUwNTA4IgogICAgICAgc29kaXBvZGk6Y3g9Ii0zMS4yODM3NiIKICAgICAgIHNvZGlwb2RpOnR5cGU9ImFyYyIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0wLjc5NzQ3NzEsMC42MDMzNDkyMSwwLjM5NDI1OTE0LDAuOTE4OTk5MzEsMCwwKSIKICAgICAgIGlkPSJwYXRoMTMxNi03LTgtNi03LTAtODMtOS0wLTktMjQtNi01LTAtNjEtMi0wIgogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDozLjA3NjUzNzEzO3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICA8ZwogICAgICAgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoODI3LjI0NTMxLC0xMzcyLjM0MzcpIgogICAgICAgaWQ9ImcxNjE5IgogICAgICAgc3R5bGU9ImZpbGw6I2Y4ZjlmYTtmaWxsLW9wYWNpdHk6MSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4Ij4KICAgICAgPGVsbGlwc2UKICAgICAgICAgcnk9IjExLjkxNjE2MSIKICAgICAgICAgcng9IjE0LjQzNjg4NyIKICAgICAgICAgY3k9IjE0ODAuNDMyOSIKICAgICAgICAgY3g9Ii03NTAuMTgyOTIiCiAgICAgICAgIGlkPSJwYXRoMTYwMCIKICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDoxLjY1MTA0ODU0O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjE7cGFpbnQtb3JkZXI6ZmlsbCBtYXJrZXJzIHN0cm9rZSIgLz4KICAgICAgPGVsbGlwc2UKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC44NzkwNTQ5MiwtMC40NzY3MjA1LDAuNTIzNjQ2MDcsMC44NTE5MzU5MSwwLDApIgogICAgICAgICByeT0iMTIuNTY2NTY3IgogICAgICAgICByeD0iMTUuNzA4NTYxIgogICAgICAgICBjeT0iOTQ2LjAxMDI1IgogICAgICAgICBjeD0iLTE0MTcuNzk2NCIKICAgICAgICAgaWQ9InBhdGgxNjAwLTMiCiAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6I2Y4ZjlmYTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS43Njg2MDcyNjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxO3BhaW50LW9yZGVyOmZpbGwgbWFya2VycyBzdHJva2UiIC8+CiAgICA8L2c+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo2Ljk4MDI2ODQ4O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItMy04LTctNiIKICAgICAgIGN4PSI1Ni4wMDAwNjkiCiAgICAgICBjeT0iMTEwLjEyNyIKICAgICAgIHJ4PSI0LjA2ODkwOTIiCiAgICAgICByeT0iNC4zNDU0NTcxIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTE4Njg4NiwtMC4xMjcyNjQxNywwLjEwMjI5MDUxLDAuOTk0NzU0NTcsMCwwKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Ny42MDI2Nzc4MjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGgxNzUyLTMtOC03IgogICAgICAgY3g9IjY5LjQ3OTUxNSIKICAgICAgIGN5PSIxMTUuNzQyNjIiCiAgICAgICByeD0iNC42NzcwNzk3IgogICAgICAgcnk9IjQuNDg0NjQxMSIKICAgICAgIHRyYW5zZm9ybT0icm90YXRlKC02LjU1MjUzMTEpIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvUGljdHVyZXMvVEhOSy9QTkcvTG9nby9HZWNrb3MucG5nIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzODcuOTM2OTgiIC8+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo1LjM1ODQ1Mzc1O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItNi03NC02LTciCiAgICAgICBjeD0iNjkuNDc5NTE1IgogICAgICAgY3k9IjExNS43NDI2MiIKICAgICAgIHJ4PSIzLjI5NjQ1ODUiCiAgICAgICByeT0iMy4xNjA4MjYiCiAgICAgICB0cmFuc2Zvcm09InJvdGF0ZSgtNi41NTI1MzExKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6Ni45OTg1NDI3OTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgZD0ibSA2Ni43MjM5OTQsOTguMDM2NDE0IGEgNC4zNjk1MzUzLDQuMDY3NzAzOSA4My40NDc0NjkgMCAwIC0wLjQwNjI2LDAuMDI1IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCAtMy41NDI0LDQuODA0Nzk2IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCA0LjUzOTc0LDMuODc3MiA0LjM2OTUzNTMsNC4wNjc3MDM5IDgzLjQ0NzQ2OSAwIDAgMy41NDI0MiwtNC44MDU0IDQuMzY5NTM1Myw0LjA2NzcwMzkgODMuNDQ3NDY5IDAgMCAtNC4xMzM1LC0zLjkwMTQ5NiB6IG0gMC4wMTk4LDAuOTUwMiBhIDMuNDE4ODUwMSwzLjE4MjY4OCA4My40NDc0NjkgMCAxIDMuMjM0OTYsMy4wNTI0OTYgMy40MTg4NTAxLDMuMTgyNjg4IDgzLjQ0NzQ2OSAwIDEgLTIuNzcxNzIsMy43NTk4IDMuNDE4ODUwMSwzLjE4MjY4OCA4My40NDc0NjkgMCAxIC0zLjU1MjMsLTMuMDMzMyAzLjQxODg1MDEsMy4xODI2ODggODMuNDQ3NDY5IDAgMSAyLjc3MTczLC0zLjc1OTc5NiAzLjQxODg1MDEsMy4xODI2ODggODMuNDQ3NDY5IDAgMSAwLjMxNzMzLC0wLjAxOSB6IgogICAgICAgaWQ9InBhdGgxNzUyLTEtNS04LTEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvUGljdHVyZXMvVEhOSy9QTkcvTG9nby9HZWNrb3MucG5nIgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjM4Ny45MzY5OCIKICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIzODcuOTM2OTgiIC8+CiAgICA8ZWxsaXBzZQogICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDojZjhmOWZhO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDo0LjkxOTc3MTY3O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpZD0icGF0aDE3NTItNi03NC02LTctNyIKICAgICAgIGN4PSI1Ni4wMDAwNjkiCiAgICAgICBjeT0iMTEwLjEyNyIKICAgICAgIHJ4PSIyLjg2NzgxMzMiCiAgICAgICByeT0iMy4wNjI3Mjc1IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTE4Njg4NiwtMC4xMjcyNjQxNywwLjEwMjI5MDUxLDAuOTk0NzU0NTcsMCwwKSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGVsbGlwc2UKICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6IzIxMjUyOTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6bm9uZTtzdHJva2Utd2lkdGg6MS42OTMxMzAyNTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgaWQ9InBhdGgxNzUyLTktNTQtOC0xIgogICAgICAgY3g9IjU3LjY3NTE5IgogICAgICAgY3k9IjEyMS43MzY0IgogICAgICAgcng9IjAuOTY4ODkwOTYiCiAgICAgICByeT0iMS4wNzM2ODA4IgogICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoLTYuNTUyNTMxMSkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxlbGxpcHNlCiAgICAgICBzdHlsZT0ib3BhY2l0eToxO3ZlY3Rvci1lZmZlY3Q6bm9uZTtmaWxsOiMyMTI1Mjk7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7c3Ryb2tlLXdpZHRoOjEuNjc1NjY3NTI7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlkPSJwYXRoMTc1Mi05LTEtNy00LTUiCiAgICAgICBjeD0iNTEuNzY1NzY2IgogICAgICAgY3k9IjExOC44OTM4NyIKICAgICAgIHJ4PSIxLjAwMTQzMDUiCiAgICAgICByeT0iMS4wMTc0NzYxIgogICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoLTYuNTUyNTMxMSkiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjQ4MjM1OTc0cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gODQuMzMyMTg0LDEwNy4zNjk5MSBjIC0wLjAzNDYsLTAuMzAwNiAtMC42NjI0OCwtMC44MTM4IC0xLjE5NDc1LC0xLjEwMDYgLTAuNjM4ODQsLTAuMzQzOSAtMC44MDU0NiwtMC42Nzc2IC0wLjY0Mjk1LC0xLjA5OTkgMC4xODQ4NywtMC40ODA4IDAuOTk2OTUsLTAuNDg0NiAxLjQ2MjQ4LC0wLjI4MTggMS40NzE1OSwwLjQ2MDkgMS41MDExNywyLjAzOTQgMS41MTEwMSwyLjEyNSAwLjA1MTIsMC40NDYyIC0wLjUxNTg3OSwyLjE3NjIxIC0xLjg0NTA0LDIuNjI0OTEgMC42MDE3MSwtMS4zODczMSAwLjc3MzkyLC0xLjcwNDYxIDAuNzA5MzMsLTIuMjY2ODEgeiIKICAgICAgIGlkPSJwYXRoMTgxMC00LTEtOSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9InNjc2NzY3MiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCIgLz4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojMjEyNTI5O2ZpbGwtb3BhY2l0eToxO3N0cm9rZTpub25lO3N0cm9rZS13aWR0aDowLjM3MzYyMzQ5cHg7c3Ryb2tlLWxpbmVjYXA6YnV0dDtzdHJva2UtbGluZWpvaW46bWl0ZXI7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGQ9Im0gNjguMDk2MTM0LDEwMi4xNTc4MSBjIC0wLjQ5NDg0LC0wLjI2NjYgLTAuNjAyMjgsLTAuNTU3MyAtMC40NzY0MSwtMC44ODQyIDAuMTQzMzIsLTAuMzcyNCAwLjc2MzA1LC0wLjYwMTYgMS4xMjM2OCwtMC40NDM5IDAuODMyNjcsMC4zNjEgMC44MjgyNywxLjUzMjcgMC43ODE2MSwxLjg0NyAtMC4wNzE4LDAuNDgzMSAtMC4wNjUzLDEuMTc2OCAtMS4wMDYwMywxLjg3NDUgMC4yMjMzNiwtMS41MDM4IDAuMjA5MDYsLTEuODkxNiAtMC40MjI3OSwtMi4zOTM0IHoiCiAgICAgICBpZD0icGF0aDE4MTAtOS00LTktNyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzb2RpcG9kaTpub2RldHlwZXM9ImNzY3NjYyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4IiAvPgogICAgPGcKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuNjE1MDY5MSwwLDAsMS42MTUwNjkxLDEzNjQuMDc0OSwtMjMyMS4xMzI2KSIKICAgICAgIGlkPSJnMjI2My0zIgogICAgICAgc3R5bGU9InN0cm9rZTojMjEyNTI5O3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICBpbmtzY2FwZTpleHBvcnQtZmlsZW5hbWU9Ii9ob21lL21pZGhpbC9QaWN0dXJlcy9USE5LL1BORy9Mb2dvL0dlY2tvcy5wbmciCiAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMzg3LjkzNjk4IgogICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjM4Ny45MzY5OCI+CiAgICAgIDxwYXRoCiAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzIxMjUyOTtzdHJva2Utd2lkdGg6MS45NTI4MTIwODtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIgogICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNy0wLTEtOC0wLTQtNS0yLTUtNiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMC45NjU3OTA5OCwwLjI1OTMyMTc5LDAuMjU5MzIxNzksLTAuOTY1NzkwOTgsMCwwKSIKICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICBzb2RpcG9kaTpjeD0iLTM3Ny45OTk2OSIKICAgICAgICAgc29kaXBvZGk6Y3k9Ii0xNjY3Ljg3MjciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIzLjE3NjE4MTgiCiAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSIzLjEyOTQyNzkiCiAgICAgICAgIHNvZGlwb2RpOmVuZD0iNC4wMjM2MDE1IgogICAgICAgICBkPSJtIC0zODcuNTI3NTMsLTE2NjcuODM0IGEgOS41Mjg1NDE2LDMuMTc2MTgxOCAwIDAgMSAzLjQ3MTQ4LC0yLjQ5MDciCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIgLz4KICAgICAgPGcKICAgICAgICAgaWQ9ImcyMjU1LTUiCiAgICAgICAgIHN0eWxlPSJzdHJva2U6IzIxMjUyOTtzdHJva2Utb3BhY2l0eToxIj4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOm9wZW49InRydWUiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgICBkPSJtIC0xNDUyLjY5NCwtOTA2LjMwNjIxIGEgMTAuMjUwNDQ0LDMuNDE2ODE2MiAwIDAgMSA2Ljg0NDcsLTEuOTMyMzUiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSI0LjQ2MjUxNDIiCiAgICAgICAgICAgc29kaXBvZGk6c3RhcnQ9IjMuNTU2ODI0MyIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy40MTY4MTYyIgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSIxMC4yNTA0NDQiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii05MDQuOTI3ODYiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9Ii0xNDQzLjMxNDYiCiAgICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODY2Mjg1NTUsLTAuNDk5NTQ5MTMsLTAuNDk5NTQ5MTMsLTAuODY2Mjg1NTUsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNi04LTM2LTMtNy02LTYiCiAgICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDoyLjEwMDc2MDc7c3Ryb2tlLWxpbmVjYXA6cm91bmQ7c3Ryb2tlLWxpbmVqb2luOnJvdW5kO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1kYXNob2Zmc2V0OjA7c3Ryb2tlLW9wYWNpdHk6MSIgLz4KICAgICAgICA8cGF0aAogICAgICAgICAgIHNvZGlwb2RpOm9wZW49InRydWUiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteGRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVY1LnBuZyIKICAgICAgICAgICBkPSJtIC0xNTA3LjI0NDQsLTgxMy41ODY0OSBhIDkuNTI4NTQxNiwzLjE3NjE4MTggMCAwIDEgNC43MzIsLTIuNzgzMTkiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSI0LjE4NDk2MjEiCiAgICAgICAgICAgc29kaXBvZGk6c3RhcnQ9IjMuMTI5NDI3OSIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy4xNzYxODE4IgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii04MTMuNjI1MTIiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9Ii0xNDk3LjcxNjYiCiAgICAgICAgICAgc29kaXBvZGk6dHlwZT0iYXJjIgogICAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuODMzMDMzNDEsLTAuNTUzMjIyNjksLTAuNTUzMjIyNjksLTAuODMzMDMzNDEsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktNy02LTAtNy03LTktMS0zIgogICAgICAgICAgIHN0eWxlPSJvcGFjaXR5OjE7dmVjdG9yLWVmZmVjdDpub25lO2ZpbGw6bm9uZTtmaWxsLW9wYWNpdHk6MTtzdHJva2U6IzIxMjUyOTtzdHJva2Utd2lkdGg6MS45NTI4MTIwODtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVjUucG5nIgogICAgICAgICAgIGQ9Im0gMTEyMy4xNTU3LC0xMjg3LjE4NDUgYSA5LjUyODU0MTYsMy4xNzYxODE4IDAgMCAxIDMuMjQ1NywtMS43NjM3IgogICAgICAgICAgIHNvZGlwb2RpOmVuZD0iNC4wMjM2MDE1IgogICAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSIzLjM2MDA3MSIKICAgICAgICAgICBzb2RpcG9kaTpyeT0iMy4xNzYxODE4IgogICAgICAgICAgIHNvZGlwb2RpOnJ4PSI5LjUyODU0MTYiCiAgICAgICAgICAgc29kaXBvZGk6Y3k9Ii0xMjg2LjQ5NjEiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9IjExMzIuNDU3OCIKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICAgICAgdHJhbnNmb3JtPSJyb3RhdGUoMTY2LjkzMDcpIgogICAgICAgICAgIGlkPSJwYXRoMTMxNi03LTgtNi03LTAtODMtOS03LTAtNi01LTktNy0yLTItMDYtOSIKICAgICAgICAgICBzdHlsZT0ib3BhY2l0eToxO3ZlY3Rvci1lZmZlY3Q6bm9uZTtmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjEuOTUyODExNjtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLWRhc2hvZmZzZXQ6MDtzdHJva2Utb3BhY2l0eToxIiAvPgogICAgICAgIDxwYXRoCiAgICAgICAgICAgc29kaXBvZGk6b3Blbj0idHJ1ZSIKICAgICAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMTY5Ljg1NzgyIgogICAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVjUuMS5wbmciCiAgICAgICAgICAgZD0ibSAxMzc3LjAwMjEsNzM4LjIyODU1IGEgMTUuMDcyNTIzLDUuMzEyNjY0NSAwIDAgMSAtMy45ODgxLDYuODM4NjIiCiAgICAgICAgICAgc29kaXBvZGk6ZW5kPSIwLjkxOTY2MTQ1IgogICAgICAgICAgIHNvZGlwb2RpOnN0YXJ0PSI1Ljc2ODk5MTQiCiAgICAgICAgICAgc29kaXBvZGk6cnk9IjUuMzEyNjY0NSIKICAgICAgICAgICBzb2RpcG9kaTpyeD0iMTUuMDcyNTIzIgogICAgICAgICAgIHNvZGlwb2RpOmN5PSI3NDAuODQxNDkiCiAgICAgICAgICAgc29kaXBvZGk6Y3g9IjEzNjMuODc4NyIKICAgICAgICAgICBzb2RpcG9kaTp0eXBlPSJhcmMiCiAgICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTAuNzk3NDc3MTEsMC42MDMzNDkyMSwwLjM5NDI1OTEzLDAuOTE4OTk5MzEsMCwwKSIKICAgICAgICAgICBpZD0icGF0aDEzMTYtNy04LTYtNy0wLTgzLTktMC05LTI0LTYtNS0wLTYtMi05LTQiCiAgICAgICAgICAgc3R5bGU9Im9wYWNpdHk6MTt2ZWN0b3ItZWZmZWN0Om5vbmU7ZmlsbDpub25lO2ZpbGwtb3BhY2l0eToxO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDoxLjkwNDg5NTA3O3N0cm9rZS1saW5lY2FwOnJvdW5kO3N0cm9rZS1saW5lam9pbjpyb3VuZDtzdHJva2UtbWl0ZXJsaW1pdDo0O3N0cm9rZS1kYXNoYXJyYXk6bm9uZTtzdHJva2UtZGFzaG9mZnNldDowO3N0cm9rZS1vcGFjaXR5OjEiIC8+CiAgICAgIDwvZz4KICAgIDwvZz4KICAgIDxnCiAgICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSg4MjcuMjQ1MzEsLTEzNzIuMzQzNykiCiAgICAgICBpZD0iZzE2MjQiCiAgICAgICBzdHlsZT0ic3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MSIKICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL1BpY3R1cmVzL1RITksvUE5HL0xvZ28vR2Vja29zLnBuZyIKICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIzODcuOTM2OTgiCiAgICAgICBpbmtzY2FwZTpleHBvcnQteWRwaT0iMzg3LjkzNjk4Ij4KICAgICAgPGcKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXlkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LXhkcGk9IjE2OS44NTc4MiIKICAgICAgICAgaW5rc2NhcGU6ZXhwb3J0LWZpbGVuYW1lPSIvaG9tZS9taWRoaWwvRG9jdW1lbnRzL1RITkstVkljb25zLnBuZyIKICAgICAgICAgc3R5bGU9InN0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDowLjc0MTE1ODEzO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgIGlkPSJnMTk1MS0wLTItNiIKICAgICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMi4wMTA2MzkxLC0wLjIzMDk1MDk3LDAuMjMwOTUwOTcsMi4wMTA2MzkxLDQxNC45MTk0NiwtMTczNi4xODYyKSI+CiAgICAgICAgPHBhdGgKICAgICAgICAgICBzdHlsZT0iZmlsbDpub25lO3N0cm9rZTojMjEyNTI5O3N0cm9rZS13aWR0aDowLjc0MTE1ODEzO3N0cm9rZS1saW5lY2FwOmJ1dHQ7c3Ryb2tlLWxpbmVqb2luOm1pdGVyO3N0cm9rZS1taXRlcmxpbWl0OjQ7c3Ryb2tlLWRhc2hhcnJheTpub25lO3N0cm9rZS1vcGFjaXR5OjEiCiAgICAgICAgICAgZD0ibSAtNzU3Ljc2NzU3LDE1MTguMDgxIGMgMCwwIDAuMTkxOSwxLjExNDYgMS42Nzg1NiwxLjMyMDcgMC42MDYzMSwwLjA4NCAxLjEyNzcsMC4xMTU0IDIuMDUzNTYsMCAxLjAyNDMyLC0wLjEzMzEgMi4zMDczNSwtMC45NjYgMi45NTYyOSwtMS44MDciCiAgICAgICAgICAgaWQ9InBhdGgxOTQ4LTctMC03IgogICAgICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICAgICAgc29kaXBvZGk6bm9kZXR5cGVzPSJjc3NjIiAvPgogICAgICA8L2c+CiAgICAgIDxwYXRoCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC15ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC14ZHBpPSIxNjkuODU3ODIiCiAgICAgICAgIGlua3NjYXBlOmV4cG9ydC1maWxlbmFtZT0iL2hvbWUvbWlkaGlsL0RvY3VtZW50cy9USE5LLVZJY29ucy5wbmciCiAgICAgICAgIHNvZGlwb2RpOm5vZGV0eXBlcz0iY3NjIgogICAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgICBpZD0icGF0aDE5NDYtMy0zLTEtMyIKICAgICAgICAgZD0ibSAtNzQ0LjIyNzA5LDE0ODguMzEwOCBjIC0wLjEzMzA3LDAuMTg2NCAtMi4xOTAyNywxLjE4OTMgLTQuOTQxNTUsMS44MDIgLTIuNTcxNDUsMC41NzIyIC01Ljc1ODIyLDAuOTM3OCAtOC42NTYyMiwwLjc2MDgiCiAgICAgICAgIHN0eWxlPSJmaWxsOm5vbmU7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOiMyMTI1Mjk7c3Ryb2tlLXdpZHRoOjEuNTtzdHJva2UtbGluZWNhcDpyb3VuZDtzdHJva2UtbGluZWpvaW46cm91bmQ7c3Ryb2tlLW1pdGVybGltaXQ6NDtzdHJva2UtZGFzaGFycmF5Om5vbmU7c3Ryb2tlLW9wYWNpdHk6MTtwYWludC1vcmRlcjpmaWxsIG1hcmtlcnMgc3Ryb2tlIiAvPgogICAgPC9nPgogIDwvZz4KPC9zdmc+Cg==",
  "name": "THNK_GeckosClient",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/lan-connect.svg",
  "shortDescription": "A THNK client adapter for networking via geckos.io (IP & Port).",
  "version": "1.0.0",
  "description": "A THNK client adapter for networking via [geckos.io](https://geckos.io), a client-server netwroking solution that uses fast UDP and encrypted connections.",
  "tags": [
    "THNK",
    "adapter",
    "client",
    "geckos",
    "io",
    "geckos.io"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1"
  ],
  "dependencies": [
    {
      "exportName": "@geckos.io/server",
      "name": "Geckos server",
      "type": "npm",
      "version": "^2.2.3"
    }
  ],
  "globalVariables": [],
  "sceneVariables": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Load THNK Geckos Client Adapter (https://github.com/arthuro555/THNK)",
            "\"use strict\";",
            "(() => {",
            "  var __create = Object.create;",
            "  var __defProp = Object.defineProperty;",
            "  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;",
            "  var __getOwnPropNames = Object.getOwnPropertyNames;",
            "  var __getProtoOf = Object.getPrototypeOf;",
            "  var __hasOwnProp = Object.prototype.hasOwnProperty;",
            "  var __commonJS = (cb, mod) => function __require() {",
            "    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;",
            "  };",
            "  var __copyProps = (to, from, except, desc) => {",
            "    if (from && typeof from === \"object\" || typeof from === \"function\") {",
            "      for (let key of __getOwnPropNames(from))",
            "        if (!__hasOwnProp.call(to, key) && key !== except)",
            "          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });",
            "    }",
            "    return to;",
            "  };",
            "  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(",
            "    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,",
            "    mod",
            "  ));",
            "",
            "  // node_modules/@yandeu/events/cjs/version.js",
            "  var require_version = __commonJS({",
            "    \"node_modules/@yandeu/events/cjs/version.js\"(exports) {",
            "      \"use strict\";",
            "      Object.defineProperty(exports, \"__esModule\", { value: true });",
            "      exports.VERSION = void 0;",
            "      exports.VERSION = \"0.0.6\";",
            "    }",
            "  });",
            "",
            "  // node_modules/@yandeu/events/cjs/index.js",
            "  var require_cjs = __commonJS({",
            "    \"node_modules/@yandeu/events/cjs/index.js\"(exports) {",
            "      \"use strict\";",
            "      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {",
            "        if (pack || arguments.length === 2)",
            "          for (var i = 0, l = from.length, ar; i < l; i++) {",
            "            if (ar || !(i in from)) {",
            "              if (!ar)",
            "                ar = Array.prototype.slice.call(from, 0, i);",
            "              ar[i] = from[i];",
            "            }",
            "          }",
            "        return to.concat(ar || Array.prototype.slice.call(from));",
            "      };",
            "      Object.defineProperty(exports, \"__esModule\", { value: true });",
            "      exports.Events = void 0;",
            "      var version_1 = require_version();",
            "      var EE = function() {",
            "        function EE2(fn, context, once) {",
            "          if (once === void 0) {",
            "            once = false;",
            "          }",
            "          this.fn = fn;",
            "          this.context = context;",
            "          this.once = once;",
            "        }",
            "        return EE2;",
            "      }();",
            "      var addListener = function(emitter, event, fn, context, once) {",
            "        if (typeof fn !== \"function\") {",
            "          throw new TypeError(\"The listener must be a function\");",
            "        }",
            "        var listener = new EE(fn, context || emitter, once);",
            "        if (!emitter._events.has(event))",
            "          emitter._events.set(event, listener), emitter._eventsCount++;",
            "        else if (!emitter._events.get(event).fn)",
            "          emitter._events.get(event).push(listener);",
            "        else",
            "          emitter._events.set(event, [emitter._events.get(event), listener]);",
            "        return emitter;",
            "      };",
            "      var clearEvent = function(emitter, event) {",
            "        if (--emitter._eventsCount === 0)",
            "          emitter._events = /* @__PURE__ */ new Map();",
            "        else",
            "          emitter._events.delete(event);",
            "      };",
            "      var Events2 = function() {",
            "        function Events3() {",
            "          this._events = /* @__PURE__ */ new Map();",
            "          this._eventsCount = 0;",
            "        }",
            "        Object.defineProperty(Events3, \"VERSION\", {",
            "          get: function() {",
            "            return version_1.VERSION;",
            "          },",
            "          enumerable: false,",
            "          configurable: true",
            "        });",
            "        Events3.prototype.eventNames = function() {",
            "          return Array.from(this._events.keys());",
            "        };",
            "        Events3.prototype.listeners = function(event) {",
            "          var handlers = this._events.get(event);",
            "          if (!handlers)",
            "            return [];",
            "          if (handlers.fn)",
            "            return [handlers.fn];",
            "          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {",
            "            ee[i] = handlers[i].fn;",
            "          }",
            "          return ee;",
            "        };",
            "        Events3.prototype.listenerCount = function(event) {",
            "          var listeners = this._events.get(event);",
            "          if (!listeners)",
            "            return 0;",
            "          if (listeners.fn)",
            "            return 1;",
            "          return listeners.length;",
            "        };",
            "        Events3.prototype.emit = function(event) {",
            "          var _a, _b;",
            "          var args = [];",
            "          for (var _i = 1; _i < arguments.length; _i++) {",
            "            args[_i - 1] = arguments[_i];",
            "          }",
            "          if (!this._events.has(event))",
            "            return false;",
            "          var listeners = this._events.get(event);",
            "          var i;",
            "          if (listeners.fn) {",
            "            if (listeners.once)",
            "              this.removeListener(event, listeners.fn, void 0, true);",
            "            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args, false)), true;",
            "          } else {",
            "            var length_1 = listeners.length;",
            "            for (i = 0; i < length_1; i++) {",
            "              if (listeners[i].once)",
            "                this.removeListener(event, listeners[i].fn, void 0, true);",
            "              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args, false));",
            "            }",
            "          }",
            "          return true;",
            "        };",
            "        Events3.prototype.on = function(event, fn, context) {",
            "          return addListener(this, event, fn, context, false);",
            "        };",
            "        Events3.prototype.once = function(event, fn, context) {",
            "          return addListener(this, event, fn, context, true);",
            "        };",
            "        Events3.prototype.removeListener = function(event, fn, context, once) {",
            "          if (!this._events.has(event))",
            "            return this;",
            "          if (!fn) {",
            "            clearEvent(this, event);",
            "            return this;",
            "          }",
            "          var listeners = this._events.get(event);",
            "          if (listeners.fn) {",
            "            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {",
            "              clearEvent(this, event);",
            "            }",
            "          } else {",
            "            for (var i = 0, events = [], length = listeners.length; i < length; i++) {",
            "              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {",
            "                events.push(listeners[i]);",
            "              }",
            "            }",
            "            if (events.length)",
            "              this._events.set(event, events.length === 1 ? events[0] : events);",
            "            else",
            "              clearEvent(this, event);",
            "          }",
            "          return this;",
            "        };",
            "        Events3.prototype.removeAllListeners = function(event) {",
            "          if (event) {",
            "            if (this._events.delete(event))",
            "              clearEvent(this, event);",
            "          } else {",
            "            this._events = /* @__PURE__ */ new Map();",
            "            this._eventsCount = 0;",
            "          }",
            "          return this;",
            "        };",
            "        Object.defineProperty(Events3.prototype, \"off\", {",
            "          get: function() {",
            "            return this.removeListener;",
            "          },",
            "          enumerable: false,",
            "          configurable: true",
            "        });",
            "        Object.defineProperty(Events3.prototype, \"addListener\", {",
            "          get: function() {",
            "            return this.on;",
            "          },",
            "          enumerable: false,",
            "          configurable: true",
            "        });",
            "        return Events3;",
            "      }();",
            "      exports.Events = Events2;",
            "    }",
            "  });",
            "",
            "  // node_modules/@geckos.io/common/lib/bridge.js",
            "  var import_events = __toESM(require_cjs(), 1);",
            "  var Bridge = class {",
            "    constructor() {",
            "      this.eventEmitter = new import_events.Events();",
            "    }",
            "    emit(eventName, data, connection = {}) {",
            "      this.eventEmitter.emit(eventName, data, connection);",
            "    }",
            "    on(eventName, cb) {",
            "      return this.eventEmitter.on(eventName, (data, options) => {",
            "        cb(data, options);",
            "      });",
            "    }",
            "    removeAllListeners() {",
            "      this.eventEmitter.removeAllListeners();",
            "    }",
            "  };",
            "  var bridge = new Bridge();",
            "",
            "  // node_modules/@geckos.io/common/lib/constants.js",
            "  var EVENTS = {",
            "    CONNECT: \"connect\",",
            "    CONNECTION: \"connection\",",
            "    DATA_CHANNEL_IS_OPEN: \"dataChannelIsOpen\",",
            "    DISCONNECT: \"disconnect\",",
            "    DISCONNECTED: \"disconnected\",",
            "    DROP: \"dropped\",",
            "    ERROR: \"error\",",
            "    RAW_MESSAGE: \"rawMessage\",",
            "    RECEIVED_FROM_DATA_CHANNEL: \"receiveFromDataChannel\",",
            "    SEND_OVER_DATA_CHANNEL: \"sendOverDataChannel\"",
            "  };",
            "  var ERRORS = {",
            "    BROWSER_NOT_SUPPORTED: \"BROWSER_NOT_SUPPORTED\",",
            "    COULD_NOT_PARSE_MESSAGE: \"COULD_NOT_PARSE_MESSAGE\",",
            "    DROPPED_FROM_BUFFERING: \"DROPPED_FROM_BUFFERING\",",
            "    MAX_MESSAGE_SIZE_EXCEEDED: \"MAX_MESSAGE_SIZE_EXCEEDED\"",
            "  };",
            "",
            "  // node_modules/@geckos.io/common/lib/types.js",
            "  var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;",
            "",
            "  // node_modules/@geckos.io/common/lib/helpers.js",
            "  var tick = typeof Promise == \"function\" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;",
            "  var isStringMessage = (data) => {",
            "    return typeof data === \"string\";",
            "  };",
            "  var isBufferMessage = (data) => {",
            "    return data instanceof ArrayBuffer || data instanceof ArrayBufferView;",
            "  };",
            "  var isJSONMessage = (data) => {",
            "    try {",
            "      if (typeof data !== \"string\")",
            "        return false;",
            "      if (!isNaN(parseInt(data)))",
            "        return false;",
            "      JSON.parse(data);",
            "      return true;",
            "    } catch (error) {",
            "      return false;",
            "    }",
            "  };",
            "",
            "  // node_modules/@geckos.io/common/lib/parseMessage.js",
            "  var ParseMessage = (ev) => {",
            "    let { data } = ev;",
            "    if (!data)",
            "      data = ev;",
            "    const isBuffer = isBufferMessage(data);",
            "    const isJson = isJSONMessage(data);",
            "    const isString = isStringMessage(data);",
            "    if (isJson) {",
            "      const object = JSON.parse(data);",
            "      const key = Object.keys(object)[0];",
            "      const value = object[key];",
            "      return { key, data: value };",
            "    }",
            "    if (isBuffer) {",
            "      return { key: EVENTS.RAW_MESSAGE, data };",
            "    }",
            "    if (isString) {",
            "      return { key: EVENTS.RAW_MESSAGE, data };",
            "    }",
            "    return { key: \"error\", data: new Error(ERRORS.COULD_NOT_PARSE_MESSAGE) };",
            "  };",
            "  var parseMessage_default = ParseMessage;",
            "",
            "  // node_modules/@geckos.io/common/lib/sendMessage.js",
            "  var SendMessage = (dataChannel, maxMessageSize, eventName, data = null) => {",
            "    var _a;",
            "    const send = (data2, isBuffer) => {",
            "      var _a2;",
            "      const bytes = (_a2 = data2.byteLength) !== null && _a2 !== void 0 ? _a2 : data2.length * 2;",
            "      if (typeof maxMessageSize === \"number\" && bytes > maxMessageSize) {",
            "        throw new Error(`maxMessageSize of ${maxMessageSize} exceeded`);",
            "      } else {",
            "        Promise.resolve().then(() => {",
            "          if (dataChannel.send)",
            "            dataChannel.send(data2);",
            "          else {",
            "            if (!isBuffer)",
            "              dataChannel.sendMessage(data2);",
            "            else",
            "              dataChannel.sendMessageBinary(Buffer.from(data2));",
            "          }",
            "        }).catch((error) => {",
            "          console.log(\"error\", error);",
            "        });",
            "      }",
            "    };",
            "    if (!dataChannel)",
            "      return;",
            "    if (dataChannel.readyState === \"open\" || ((_a = dataChannel.isOpen) === null || _a === void 0 ? void 0 : _a.call(dataChannel))) {",
            "      try {",
            "        if (eventName === EVENTS.RAW_MESSAGE && data !== null && (isStringMessage(data) || isBufferMessage(data))) {",
            "          send(data, isBufferMessage(data));",
            "        } else {",
            "          send(JSON.stringify({ [eventName]: data }), false);",
            "        }",
            "      } catch (error) {",
            "        console.error(\"Error in sendMessage.ts: \", error.message);",
            "        return error;",
            "      }",
            "    }",
            "  };",
            "  var sendMessage_default = SendMessage;",
            "",
            "  // node_modules/@geckos.io/client/lib/wrtc/connectionsManager.js",
            "  var ConnectionsManagerClient = class {",
            "    constructor(url, authorization, label, rtcConfiguration) {",
            "      this.url = url;",
            "      this.authorization = authorization;",
            "      this.label = label;",
            "      this.rtcConfiguration = rtcConfiguration;",
            "      this.bridge = new Bridge();",
            "      this.onDataChannel = (ev) => {",
            "        const { channel } = ev;",
            "        if (channel.label !== this.label)",
            "          return;",
            "        this.dataChannel = channel;",
            "        this.dataChannel.binaryType = \"arraybuffer\";",
            "        this.dataChannel.onmessage = (ev2) => {",
            "          const { key, data } = parseMessage_default(ev2);",
            "          this.bridge.emit(key, data);",
            "        };",
            "      };",
            "    }",
            "    emit(eventName, data = null) {",
            "      sendMessage_default(this.dataChannel, this.maxMessageSize, eventName, data);",
            "    }",
            "    async fetchAdditionalCandidates(host, id) {",
            "      var _a;",
            "      if (((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.readyState) === \"closed\")",
            "        return;",
            "      const res = await fetch(`${host}/connections/${id}/additional-candidates`, {",
            "        method: \"GET\",",
            "        headers: {",
            "          \"Content-Type\": \"application/json\"",
            "        }",
            "      });",
            "      if (res.ok) {",
            "        const candidates = await res.json();",
            "        candidates.forEach((c) => {",
            "          this.localPeerConnection.addIceCandidate(c);",
            "        });",
            "      }",
            "    }",
            "    async connect() {",
            "      const host = `${this.url}/.wrtc/v2`;",
            "      let headers = { \"Content-Type\": \"application/json\" };",
            "      if (this.authorization)",
            "        headers = { ...headers, [\"Authorization\"]: this.authorization };",
            "      let userData = {};",
            "      try {",
            "        const res = await fetch(`${host}/connections`, {",
            "          method: \"POST\",",
            "          headers",
            "        });",
            "        if (res.status >= 300) {",
            "          throw {",
            "            name: \"Error\",",
            "            message: `Connection failed with status code ${res.status}.`,",
            "            status: res.status,",
            "            statusText: res.statusText",
            "          };",
            "        }",
            "        const json = await res.json();",
            "        userData = json.userData;",
            "        this.remotePeerConnection = json;",
            "      } catch (error) {",
            "        console.error(error.message);",
            "        return { error };",
            "      }",
            "      const { id, localDescription } = this.remotePeerConnection;",
            "      const configuration = {",
            "        sdpSemantics: \"unified-plan\",",
            "        ...this.rtcConfiguration",
            "      };",
            "      const RTCPc = RTCPeerConnection || webkitRTCPeerConnection;",
            "      this.localPeerConnection = new RTCPc(configuration);",
            "      const showBackOffIntervals = (attempts = 10, initial = 50, factor = 1.8, jitter = 20) => Array(attempts).fill(0).map((_, index) => parseInt((initial * factor ** index).toString()) + parseInt((Math.random() * jitter).toString()));",
            "      showBackOffIntervals().forEach((ms) => {",
            "        setTimeout(() => {",
            "          this.fetchAdditionalCandidates(host, id).catch(() => {",
            "          });",
            "        }, ms);",
            "      });",
            "      try {",
            "        await this.localPeerConnection.setRemoteDescription(localDescription);",
            "        this.localPeerConnection.addEventListener(\"datachannel\", this.onDataChannel, { once: true });",
            "        const originalAnswer = await this.localPeerConnection.createAnswer();",
            "        const updatedAnswer = new RTCSessionDescription({",
            "          type: \"answer\",",
            "          sdp: originalAnswer.sdp",
            "        });",
            "        await this.localPeerConnection.setLocalDescription(updatedAnswer);",
            "        try {",
            "          await fetch(`${host}/connections/${id}/remote-description`, {",
            "            method: \"POST\",",
            "            body: JSON.stringify(this.localPeerConnection.localDescription),",
            "            headers: {",
            "              \"Content-Type\": \"application/json\"",
            "            }",
            "          });",
            "        } catch (error) {",
            "          console.error(error.message);",
            "          return { error };",
            "        }",
            "        const waitForDataChannel = () => {",
            "          return new Promise((resolve) => {",
            "            this.localPeerConnection.addEventListener(\"datachannel\", () => {",
            "              resolve();",
            "            }, { once: true });",
            "          });",
            "        };",
            "        if (!this.dataChannel)",
            "          await waitForDataChannel();",
            "        return {",
            "          userData,",
            "          localPeerConnection: this.localPeerConnection,",
            "          dataChannel: this.dataChannel,",
            "          id",
            "        };",
            "      } catch (error) {",
            "        console.error(error.message);",
            "        this.localPeerConnection.close();",
            "        return { error };",
            "      }",
            "    }",
            "  };",
            "",
            "  // node_modules/@geckos.io/client/lib/wrtc/peerConnection.js",
            "  var PeerConnection = class {",
            "    async connect(connectionsManager) {",
            "      const webRTCPcSupported = RTCPeerConnection || webkitRTCPeerConnection;",
            "      if (webRTCPcSupported) {",
            "        const { localPeerConnection, dataChannel, id, userData, error } = await connectionsManager.connect();",
            "        if (error)",
            "          return { error };",
            "        if (!localPeerConnection || !dataChannel || !id || !userData)",
            "          return { error: new Error('Something went wrong in \"await connectionsManager.connect()\"') };",
            "        this.localPeerConnection = localPeerConnection;",
            "        this.dataChannel = dataChannel;",
            "        this.id = id;",
            "        return { userData };",
            "      } else {",
            "        const error = new Error(ERRORS.BROWSER_NOT_SUPPORTED);",
            "        console.error(error.message);",
            "        return { error };",
            "      }",
            "    }",
            "  };",
            "",
            "  // node_modules/@geckos.io/common/lib/makeRandomId.js",
            "  var makeRandomId = (length = 24) => {",
            "    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";",
            "    let id = \"\";",
            "    for (let i = 0; i < length; i++) {",
            "      id += possible.charAt(Math.floor(Math.random() * possible.length));",
            "    }",
            "    return id;",
            "  };",
            "  var makeRandomId_default = makeRandomId;",
            "",
            "  // node_modules/@geckos.io/common/lib/runInterval.js",
            "  var runInterval = (interval = 200, runs = 1, cb) => {",
            "    let counter = 0;",
            "    if (typeof cb !== \"function\") {",
            "      console.error(\"You have to define your callback function!\");",
            "      return;",
            "    }",
            "    const i = setInterval(() => {",
            "      cb();",
            "      counter++;",
            "      if (counter === runs - 1) {",
            "        clearInterval(i);",
            "      }",
            "    }, interval);",
            "    cb();",
            "  };",
            "  var runInterval_default = runInterval;",
            "",
            "  // node_modules/@geckos.io/common/lib/reliableMessage.js",
            "  var makeReliable = (options, cb) => {",
            "    const { interval = 150, runs = 10 } = options;",
            "    const id = makeRandomId_default(24);",
            "    runInterval_default(interval, runs, () => {",
            "      cb(id);",
            "    });",
            "  };",
            "",
            "  // node_modules/@geckos.io/client/lib/geckos/channel.js",
            "  var ClientChannel = class {",
            "    constructor(url, authorization, port, label, rtcConfiguration) {",
            "      this.userData = {};",
            "      this.receivedReliableMessages = [];",
            "      this.url = port ? `${url}:${port}` : url;",
            "      this.connectionsManager = new ConnectionsManagerClient(this.url, authorization, label, rtcConfiguration);",
            "      this.bridge = this.connectionsManager.bridge;",
            "      this.bridge.on(EVENTS.DISCONNECTED, () => this.bridge.removeAllListeners());",
            "    }",
            "    onconnectionstatechange() {",
            "      const lpc = this.peerConnection.localPeerConnection;",
            "      lpc.onconnectionstatechange = () => {",
            "        if (lpc.connectionState === \"disconnected\" || lpc.connectionState === \"closed\")",
            "          this.bridge.emit(EVENTS.DISCONNECTED);",
            "      };",
            "    }",
            "    get id() {",
            "      return this.peerConnection.id;",
            "    }",
            "    close() {",
            "      this.peerConnection.localPeerConnection.close();",
            "      this.bridge.emit(EVENTS.DISCONNECTED);",
            "      try {",
            "        const host = `${this.url}/.wrtc/v2`;",
            "        fetch(`${host}/connections/${this.id}/close`, {",
            "          method: \"POST\",",
            "          headers: {",
            "            \"Content-Type\": \"application/json\"",
            "          }",
            "        });",
            "      } catch (error) {",
            "        console.error(error.message);",
            "      }",
            "    }",
            "    emit(eventName, data = null, options) {",
            "      if (options && options.reliable) {",
            "        makeReliable(options, (id) => this.connectionsManager.emit(eventName, {",
            "          MESSAGE: data,",
            "          RELIABLE: 1,",
            "          ID: id",
            "        }));",
            "      } else {",
            "        this.connectionsManager.emit(eventName, data);",
            "      }",
            "    }",
            "    get raw() {",
            "      return {",
            "        emit: (rawMessage) => this.emit(EVENTS.RAW_MESSAGE, rawMessage)",
            "      };",
            "    }",
            "    onRaw(callback) {",
            "      this.bridge.on(EVENTS.RAW_MESSAGE, (rawMessage) => {",
            "        const cb = (rawMessage2) => callback(rawMessage2);",
            "        cb(rawMessage);",
            "      });",
            "    }",
            "    async onConnect(callback) {",
            "      var _a;",
            "      this.peerConnection = new PeerConnection();",
            "      const response = await this.peerConnection.connect(this.connectionsManager);",
            "      if (response.error)",
            "        callback(response.error);",
            "      else {",
            "        if (response.userData)",
            "          this.userData = response.userData;",
            "        this.maxMessageSize = this.connectionsManager.maxMessageSize = (_a = this.peerConnection.localPeerConnection.sctp) === null || _a === void 0 ? void 0 : _a.maxMessageSize;",
            "        this.onconnectionstatechange();",
            "        callback();",
            "      }",
            "    }",
            "    onDisconnect(callback) {",
            "      this.bridge.on(EVENTS.DISCONNECTED, callback);",
            "    }",
            "    on(eventName, callback) {",
            "      this.bridge.on(eventName, (data) => {",
            "        const isReliableMessage = data && data.RELIABLE === 1 && data.ID !== \"undefined\";",
            "        const expireTime = 15e3;",
            "        const deleteExpiredReliableMessages = () => {",
            "          const currentTime = new Date().getTime();",
            "          this.receivedReliableMessages.forEach((msg, index, object) => {",
            "            if (msg.expire <= currentTime) {",
            "              object.splice(index, 1);",
            "            }",
            "          });",
            "        };",
            "        if (isReliableMessage) {",
            "          deleteExpiredReliableMessages();",
            "          if (this.receivedReliableMessages.filter((obj) => obj.id === data.ID).length === 0) {",
            "            this.receivedReliableMessages.push({",
            "              id: data.ID,",
            "              timestamp: new Date(),",
            "              expire: new Date().getTime() + expireTime",
            "            });",
            "            callback(data.MESSAGE);",
            "          } else {",
            "          }",
            "        } else {",
            "          callback(data);",
            "        }",
            "      });",
            "    }",
            "  };",
            "  var geckosClient = (options = {}) => {",
            "    const { authorization = void 0, iceServers = [], iceTransportPolicy = \"all\", label = \"geckos.io\", port = 9208, url = `${location.protocol}//${location.hostname}` } = options;",
            "    return new ClientChannel(url, authorization, port, label, { iceServers, iceTransportPolicy });",
            "  };",
            "  var channel_default = geckosClient;",
            "",
            "  // code/adapters/geckos-client.ts",
            "  var logger = new gdjs.Logger(\"THNK - Geckos.io Adapter\");",
            "  THNK.GeckosClientAdapter = class GeckosClientAdapter extends THNK.ClientAdapter {",
            "    ip;",
            "    port;",
            "    connection = null;",
            "    constructor(ip, port) {",
            "      super();",
            "      this.ip = `http://${ip}`;",
            "      this.port = port;",
            "    }",
            "    async prepare() {",
            "      this.connection = channel_default({ url: this.ip, port: this.port, label: \"THNK\" });",
            "      await new Promise(",
            "        (resolve, reject) => this.connection.onConnect((error) => {",
            "          if (error)",
            "            return reject(error.message);",
            "          this.connection.onRaw(",
            "            (message) => this.onMessage(message)",
            "          );",
            "          this.connection.onDisconnect(() => this.onDisconnection());",
            "          resolve();",
            "        })",
            "      );",
            "    }",
            "    close() {",
            "      if (this.connection)",
            "        this.connection.close();",
            "    }",
            "    doSendMessage(message) {",
            "      if (!this.connection) {",
            "        return logger.error(",
            "          \"Tried to send a message on an unestablished connection!\"",
            "        );",
            "      }",
            "      this.connection.raw.emit(",
            "        message.buffer.slice(message.buffer.byteLength - message.byteLength)",
            "      );",
            "    }",
            "    getServerIP() {",
            "      return this.ip;",
            "    }",
            "    getServerPort() {",
            "      return this.port;",
            "    }",
            "  };",
            "})();",
            "/**",
            " * @package      npmjs.com/package/@yandeu/events (events.min.js)",
            " *",
            " * @author       Arnout Kazemier (https://github.com/3rd-Eden)",
            " * @copyright    Copyright (c) 2014 Arnout Kazemier",
            " * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}",
            " *",
            " * @author       Yannick Deubel (https://github.com/yandeu)",
            " * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events",
            " * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}",
            " */",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Connects to a geckos.io THNK server.",
      "fullName": "Connect to server",
      "functionType": "Action",
      "name": "ConnectToServer",
      "sentence": "Connect to server at _PARAM1_:_PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.client.startClient(",
            "    runtimeScene,",
            "    new THNK.GeckosClientAdapter(",
            "        eventsFunctionContext.getArgument(\"Host\"),",
            "        eventsFunctionContext.getArgument(\"Port\")",
            "    )",
            ");",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Hostname (URL or IP address)",
          "name": "Host",
          "type": "string"
        },
        {
          "description": "The port the server is hosted on",
          "name": "Port",
          "type": "expression"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Check if the current scene is running with the Geckos Client adapter.",
      "fullName": "Geckos client adapter in use",
      "functionType": "Condition",
      "name": "IsGeckosClientInUse",
      "sentence": "Geckos client is running",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "eventsFunctionContext.returnValue = runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter;\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "the IP address the running geckos client listens to",
      "fullName": "IP address",
      "functionType": "ExpressionAndCondition",
      "name": "ServerIP",
      "sentence": "Geckos server IP address",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter)\r",
            "    eventsFunctionContext.returnValue = runtimeScene.thnkClient.adapter.getServerIP()\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "string"
      },
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "the port of the server the running geckos client is connected to",
      "fullName": "Server Port",
      "functionType": "ExpressionAndCondition",
      "name": "ServerPort",
      "sentence": "Server port",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "if (runtimeScene.thnkClient && runtimeScene.thnkClient.adapter instanceof THNK.GeckosClientAdapter)\r",
            "    eventsFunctionContext.returnValue = runtimeScene.thnkClient.adapter.getServerPort()\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "expressionType": {
        "type": "expression"
      },
      "parameters": [],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}